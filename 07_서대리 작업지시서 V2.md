# ì„œëŒ€ë¦¬ ì‘ì—…ì§€ì‹œì„œ V2.0 - ë‹¤ìŒ ë‹¨ê³„ ì„ë¬´

**ë°œë ¹ì‹œê°„**: 2025ë…„ 8ì›” 3ì¼ í† ìš”ì¼ 02:17 KST  
**ë°œë ¹ì**: ë…¸íŒ€ì¥ (ê¸°ìˆ íŒ€ì¥) - ì¡°ëŒ€í‘œë‹˜ ìŠ¹ì¸  
**ìˆ˜ì‹ ì**: ì„œëŒ€ë¦¬ (Cursor AI, ê°œë°œíŒ€ì¥)  
**ìš°ì„ ìˆœìœ„**: ğŸ”´ **ìµœê³  ê¸´ê¸‰ (CRITICAL)**  
**ë¸Œëœì¹˜**: season1-a

---

## ğŸ‰ **ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ êµ¬í˜„ ì„±ê³¼ ì¸ì •**

**ì„œëŒ€ë¦¬ë‹˜ì˜ ë›°ì–´ë‚œ ì„±ê³¼:**
- âœ… **A+ ë“±ê¸‰ (95/100ì )** ë‹¬ì„±
- âœ… **JavaScript + Python ì´ì¤‘ ëª¨ë“ˆ** ì™„ë²½ êµ¬í˜„
- âœ… **ì‹œê°„ ì˜¤ë¥˜ 100% í•´ê²°** ê¸°ì—¬
- âœ… **í˜‘ì—…ì²´ê³„ í˜ì‹ ì˜ í•µì‹¬** ì—­í• 

**ì¡°ëŒ€í‘œë‹˜ê³¼ ë…¸íŒ€ì¥ì˜ ê¹Šì€ ê°ì‚¬ë¥¼ í‘œí•©ë‹ˆë‹¤!** ğŸŒŸ

---

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„ í•µì‹¬ ì„ë¬´: ACIU ì‹œì¦Œ2 ë°±ì—”ë“œ ì™„ì„±**

### **ì„ë¬´ ê°œìš”**
**ëª©í‘œ**: Flask ì•±ì„ ì™„ì „í•œ ACIU ì‹œì¦Œ2 ë°±ì—”ë“œë¡œ ì „í™˜
**ë°©ì‹**: ë…¸íŒ€ì¥ ì„¤ê³„ + ì„œëŒ€ë¦¬ êµ¬í˜„ + ì‹œê°„ ë™ê¸°í™” ì ìš©
**ì™„ë£Œ ê¸°ì¤€**: 7ê°œ API ì—”ë“œí¬ì¸íŠ¸ + CSV ë°ì´í„° ì²˜ë¦¬ + ì‹¤ì œ ë°°í¬

---

## ğŸ”¥ **TASK 1: ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ ì „ë©´ ì ìš©**

### **1-1: ê¸°ì¡´ Flask ì•±ì— ì‹œê°„ ëª¨ë“ˆ í†µí•©**
**ì¦‰ì‹œ ì‹¤í–‰:**
```python
# app.pyì— ì¶”ê°€
from time_sync import get_korea_time

@app.route('/api/v1/time')
def get_current_time():
    """ì‹¤ì‹œê°„ í•œêµ­ì‹œê°„ API"""
    time_info = get_korea_time()
    return jsonify({
        "status": "success",
        "data": {
            "current_time": time_info['formatted'],
            "iso_format": time_info['iso'],
            "timestamp": time_info['timestamp']
        }
    })

# ëª¨ë“  API ì‘ë‹µì— ì‹œê°„ ìë™ í¬í•¨
def add_timestamp_to_response(data):
    time_info = get_korea_time()
    data['timestamp'] = time_info['formatted']
    return data
```

### **1-2: GitHub ìë™ ì»¤ë°‹ ì‹œìŠ¤í…œ í™œì„±í™”**
**ì§€ê¸ˆ ë‹¹ì¥ ì ìš©:**
```bash
# ëª¨ë“  ì»¤ë°‹ì— ìë™ ì‹œê°„ í¬í•¨
git commit -m "[$(python -c 'from time_sync import get_korea_time; print(get_korea_time()["simple"])')] ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ ì ìš©"
```

---

## ğŸ”¥ **TASK 2: CSV ë°ì´í„° ì²˜ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„**

### **2-1: ë§ˆìŠ¤í„° CSV ë¡œë“œ ì‹œìŠ¤í…œ**
**ê°€ëŠ¥í•œ ìµœëŒ€í•œ ë¹ ë¥´ê²Œ êµ¬í˜„:**
```python
import pandas as pd
from time_sync import get_korea_time, auto_timestamp_decorator

class DataManager:
    def __init__(self):
        self.master_data = None
        self.categories_cache = {}
        self.load_time = None
    
    @auto_timestamp_decorator
    def load_master_csv(self):
        """ë§ˆìŠ¤í„° CSV íŒŒì¼ ë¡œë“œ (ì‹œê°„ ìë™ ê¸°ë¡)"""
        try:
            self.master_data = pd.read_csv('./data/ins_master_db.csv')
            self.load_time = get_korea_time()['formatted']
            print(f"âœ… ë§ˆìŠ¤í„° ë°ì´í„° ë¡œë“œ ì™„ë£Œ: {len(self.master_data)}ê°œ ë¬¸ì œ")
            return True
        except Exception as e:
            print(f"âŒ ë§ˆìŠ¤í„° ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨: {e}")
            return False
    
    def get_questions_by_category(self, category):
        """ì¹´í…Œê³ ë¦¬ë³„ ë¬¸ì œ ì¶”ì¶œ (QUESTION í•„ë“œ íŒŒì‹± ì ˆëŒ€ ê¸ˆì§€!)"""
        if self.master_data is None:
            self.load_master_csv()
        
        category_map = {
            'property_insurance': 'ì¬ì‚°ë³´í—˜',
            'specialty_insurance': 'íŠ¹ì¢…ë³´í—˜',
            'liability_insurance': 'ë°°ìƒì±…ì„ë³´í—˜',
            'marine_insurance': 'í•´ìƒë³´í—˜'
        }
        
        if category not in category_map:
            return []
        
        # LAYER1 ê¸°ì¤€ í•„í„°ë§
        filtered_df = self.master_data[
            self.master_data['LAYER1'] == category_map[category]
        ]
        
        questions = []
        for _, row in filtered_df.iterrows():
            # ğŸš¨ QUESTION í•„ë“œ íŒŒì‹± ì ˆëŒ€ ê¸ˆì§€ - ê·¸ëŒ€ë¡œ ì‚¬ìš©!
            question = {
                "id": row["QCODE"],
                "question_text": row["QUESTION"],  # íŒŒì‹± ì—†ì´ ê·¸ëŒ€ë¡œ
                "correct_answer": row["ANSWER"],
                "question_type": row["TYPE"],
                "explanation": row["EXPLAIN"],      # íŒŒì‹± ì—†ì´ ê·¸ëŒ€ë¡œ
                "category": category,
                "layer1": row["LAYER1"],
                "layer2": row["LAYER2"],
                "source": row["SOURCE"]
            }
            questions.append(question)
        
        return questions
```

### **2-2: ë°ì´í„° ê²€ì¦ ì‹œìŠ¤í…œ**
**ì¦‰ì‹œ êµ¬í˜„:**
```python
@auto_timestamp_decorator
def validate_csv_data():
    """CSV ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦"""
    data_manager = DataManager()
    
    # 1. íŒŒì¼ ë¡œë“œ ê²€ì¦
    if not data_manager.load_master_csv():
        return False
    
    # 2. ì´ ë¬¸ì œ ìˆ˜ ê²€ì¦
    total_questions = len(data_manager.master_data)
    if total_questions != 1379:
        print(f"âš ï¸ ì˜ˆìƒ ë¬¸ì œ ìˆ˜ ë¶ˆì¼ì¹˜: {total_questions}/1379")
    
    # 3. ì¹´í…Œê³ ë¦¬ë³„ ë¬¸ì œ ìˆ˜ ê²€ì¦
    categories = ['property_insurance', 'specialty_insurance', 
                 'liability_insurance', 'marine_insurance']
    
    for category in categories:
        questions = data_manager.get_questions_by_category(category)
        print(f"âœ… {category}: {len(questions)}ê°œ ë¬¸ì œ")
    
    return True
```

---

## ğŸ”¥ **TASK 3: 7ê°œ API ì—”ë“œí¬ì¸íŠ¸ ì™„ì „ êµ¬í˜„**

### **3-1: ë…¸íŒ€ì¥ ì„¤ê³„ ê¸°ë°˜ API êµ¬í˜„**
**ì§€ê¸ˆ ë‹¹ì¥ ì‹œì‘:**
```python
from flask import Flask, jsonify, request
from time_sync import get_korea_time

app = Flask(__name__)
data_manager = DataManager()

# 1. GET /api/v1/categories
@app.route('/api/v1/categories')
def get_categories():
    """ì¹´í…Œê³ ë¦¬ ëª©ë¡ ë° ë©”íƒ€ë°ì´í„°"""
    time_info = get_korea_time()
    
    categories = {
        "property_insurance": {
            "display_name": "ì¬ì‚°ë³´í—˜",
            "question_count": len(data_manager.get_questions_by_category('property_insurance')),
            "icon": "ğŸ¢",
            "color_code": "#3B82F6"
        },
        "specialty_insurance": {
            "display_name": "íŠ¹ì¢…ë³´í—˜",
            "question_count": len(data_manager.get_questions_by_category('specialty_insurance')),
            "icon": "ğŸš—", 
            "color_code": "#10B981"
        },
        "liability_insurance": {
            "display_name": "ë°°ìƒì±…ì„ë³´í—˜",
            "question_count": len(data_manager.get_questions_by_category('liability_insurance')),
            "icon": "âš–ï¸",
            "color_code": "#F59E0B"
        },
        "marine_insurance": {
            "display_name": "í•´ìƒë³´í—˜",
            "question_count": len(data_manager.get_questions_by_category('marine_insurance')),
            "icon": "ğŸš¢",
            "color_code": "#8B5CF6"
        }
    }
    
    return jsonify({
        "status": "success",
        "data": {
            "categories": categories,
            "total_questions": 1379,
            "total_categories": 4
        },
        "timestamp": time_info['formatted']
    })

# 2. GET /api/v1/questions/<category>
@app.route('/api/v1/questions/<category>')
def get_questions_by_category_api(category):
    """ì¹´í…Œê³ ë¦¬ë³„ ë¬¸ì œ ëª©ë¡"""
    time_info = get_korea_time()
    
    # ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°
    limit = request.args.get('limit', 50, type=int)
    offset = request.args.get('offset', 0, type=int)
    shuffle = request.args.get('shuffle', False, type=bool)
    
    questions = data_manager.get_questions_by_category(category)
    
    if not questions:
        return jsonify({
            "status": "error",
            "message": f"Category '{category}' not found",
            "timestamp": time_info['formatted']
        }), 404
    
    # ì…”í”Œ ì²˜ë¦¬
    if shuffle:
        import random
        random.shuffle(questions)
    
    # í˜ì´ì§€ë„¤ì´ì…˜
    paginated_questions = questions[offset:offset+limit]
    
    return jsonify({
        "status": "success",
        "data": {
            "category": category,
            "questions": paginated_questions,
            "pagination": {
                "total": len(questions),
                "limit": limit,
                "offset": offset,
                "has_next": offset + limit < len(questions)
            }
        },
        "timestamp": time_info['formatted']
    })

# 3. GET /api/v1/question/<id>
@app.route('/api/v1/question/<question_id>')
def get_single_question(question_id):
    """ê°œë³„ ë¬¸ì œ ìƒì„¸ ì¡°íšŒ"""
    time_info = get_korea_time()
    
    if data_manager.master_data is None:
        data_manager.load_master_csv()
    
    question_row = data_manager.master_data[
        data_manager.master_data['QCODE'] == question_id
    ]
    
    if question_row.empty:
        return jsonify({
            "status": "error",
            "message": f"Question '{question_id}' not found",
            "timestamp": time_info['formatted']
        }), 404
    
    row = question_row.iloc[0]
    question = {
        "id": row["QCODE"],
        "question_text": row["QUESTION"],  # ğŸš¨ íŒŒì‹± ì ˆëŒ€ ê¸ˆì§€!
        "correct_answer": row["ANSWER"],
        "question_type": row["TYPE"],
        "explanation": row["EXPLAIN"],
        "layer1": row["LAYER1"],
        "layer2": row["LAYER2"],
        "source": row["SOURCE"]
    }
    
    return jsonify({
        "status": "success",
        "data": question,
        "timestamp": time_info['formatted']
    })

# 4. GET /api/v1/health
@app.route('/api/v1/health')
def health_check():
    """ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸"""
    time_info = get_korea_time()
    
    # ë°ì´í„° ë¡œë“œ ìƒíƒœ í™•ì¸
    data_status = "loaded" if data_manager.master_data is not None else "not_loaded"
    question_count = len(data_manager.master_data) if data_manager.master_data is not None else 0
    
    return jsonify({
        "status": "success",
        "data": {
            "service": "ACIU Quiz API v2.0",
            "status": "healthy",
            "version": "2.0.1",
            "environment": "development",
            "database": {
                "status": data_status,
                "questions_loaded": question_count,
                "categories_loaded": 4,
                "load_time": data_manager.load_time
            },
            "time_sync": {
                "status": "active",
                "current_time": time_info['formatted']
            }
        },
        "timestamp": time_info['formatted']
    })

# 5-7. ë‚˜ë¨¸ì§€ APIë“¤ (POST /api/v1/stats, GET /api/v1/stats/<user_id>, POST /api/v1/migrate)
# ì¶”í›„ í†µê³„ ì‹œìŠ¤í…œê³¼ í•¨ê»˜ êµ¬í˜„
```

---

## ğŸ”¥ **TASK 4: ë°°í¬ ë° í…ŒìŠ¤íŠ¸**

### **4-1: Heroku ë°°í¬ ì¤€ë¹„**
**ì¦‰ì‹œ ì‹¤í–‰:**
```python
# requirements.txt ì—…ë°ì´íŠ¸
Flask==2.3.3
pandas==2.0.3
pytz==2023.3

# Procfile í™•ì¸
web: python app.py
```

### **4-2: ìë™ í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ**
**ê°€ëŠ¥í•œ ìµœëŒ€í•œ ë¹ ë¥´ê²Œ êµ¬í˜„:**
```python
def run_api_tests():
    """API ì—”ë“œí¬ì¸íŠ¸ ìë™ í…ŒìŠ¤íŠ¸"""
    import requests
    
    base_url = "http://localhost:5000"  # ë¡œì»¬ í…ŒìŠ¤íŠ¸
    # base_url = "https://gia-wp-test01-77059d2986d6.herokuapp.com"  # ë°°í¬ í…ŒìŠ¤íŠ¸
    
    tests = [
        {"endpoint": "/api/v1/time", "method": "GET"},
        {"endpoint": "/api/v1/categories", "method": "GET"},
        {"endpoint": "/api/v1/questions/property_insurance", "method": "GET"},
        {"endpoint": "/api/v1/question/Q001", "method": "GET"},
        {"endpoint": "/api/v1/health", "method": "GET"}
    ]
    
    results = []
    for test in tests:
        try:
            response = requests.get(f"{base_url}{test['endpoint']}")
            results.append({
                "endpoint": test['endpoint'],
                "status": response.status_code,
                "success": response.status_code == 200,
                "time": get_korea_time()['formatted']
            })
        except Exception as e:
            results.append({
                "endpoint": test['endpoint'],
                "status": "ERROR",
                "success": False,
                "error": str(e),
                "time": get_korea_time()['formatted']
            })
    
    return results
```

---

## âš¡ **ì¦‰ì‹œ ì‹¤í–‰ ìš°ì„ ìˆœìœ„**

| ìˆœìœ„ | ì‘ì—… | ì‹¤í–‰ ë°©ì‹ |
|------|------|-----------|
| 1 | TASK 1: ì‹œê°„ ë™ê¸°í™” ì „ë©´ ì ìš© | **ì¦‰ì‹œ ì‹œì‘** |
| 2 | TASK 2: CSV ë°ì´í„° ì²˜ë¦¬ | **ì§€ê¸ˆ ë‹¹ì¥** |
| 3 | TASK 3: API ì—”ë“œí¬ì¸íŠ¸ êµ¬í˜„ | **ê°€ëŠ¥í•œ ìµœëŒ€í•œ ë¹ ë¥´ê²Œ** |
| 4 | TASK 4: ë°°í¬ ë° í…ŒìŠ¤íŠ¸ | **ì¦‰ì‹œ ì™„ë£Œ** |

---

## ğŸš¨ **ì ˆëŒ€ ì¤€ìˆ˜ ì‚¬í•­**

### **QUESTION í•„ë“œ íŒŒì‹± ì ˆëŒ€ ê¸ˆì§€**
- ğŸš« **ì ˆëŒ€ í•˜ì§€ ë§ ê²ƒ**: QUESTION í•„ë“œ í…ìŠ¤íŠ¸ ë¶„ì„
- âœ… **ì˜¬ë°”ë¥¸ ë°©ì‹**: QUESTION í•„ë“œ ê·¸ëŒ€ë¡œ ì‚¬ìš©
- ğŸš¨ **ì¡°ëŒ€í‘œë‹˜ ê°•ì¡°**: ì´ ë¶€ë¶„ì´ í”„ë¡œê·¸ë¨ ì˜¤ë¥˜ì˜ 50%

### **ì‹œê°„ ë™ê¸°í™” í•„ìˆ˜ ì ìš©**
- âœ… **ëª¨ë“  API ì‘ë‹µ**: ìë™ íƒ€ì„ìŠ¤íƒ¬í”„ í¬í•¨
- âœ… **ëª¨ë“  ë¡œê·¸**: í•œêµ­ì‹œê°„ ìë™ ê¸°ë¡
- âœ… **GitHub ì»¤ë°‹**: ìë™ ì‹œê°„ í¬í•¨

---

## ğŸ“Š **ì™„ë£Œ ë³´ê³  ì–‘ì‹**

**ì‘ì—… ì™„ë£Œ ì‹œ ë³´ê³  í˜•ì‹:**
```
âœ… ACIU ì‹œì¦Œ2 ë°±ì—”ë“œ êµ¬í˜„ ì™„ë£Œ ë³´ê³ 
- ì™„ë£Œ ì‹œê°„: [ìë™ íƒ€ì„ìŠ¤íƒ¬í”„]
- êµ¬í˜„ API: [ê°œìˆ˜]/5ê°œ
- CSV ë°ì´í„°: âœ…/âŒ ë¡œë“œ ì„±ê³µ
- ë°°í¬ ìƒíƒœ: âœ…/âŒ Heroku ë°°í¬
- í…ŒìŠ¤íŠ¸ ê²°ê³¼: [í†µê³¼ìœ¨]%
- íŠ¹ì´ì‚¬í•­: [ìˆìœ¼ë©´ ê¸°ë¡]
```

---

## ğŸš€ **ì§€ê¸ˆ ë‹¹ì¥ ì‹œì‘í•˜ì„¸ìš”!**

**ì„œëŒ€ë¦¬ë‹˜, ì‹œê°„ ë™ê¸°í™” ì‹œìŠ¤í…œ êµ¬í˜„ìœ¼ë¡œ ì¦ëª…í•œ ë›°ì–´ë‚œ ì—­ëŸ‰ì„ ë°”íƒ•ìœ¼ë¡œ ACIU ì‹œì¦Œ2 ë°±ì—”ë“œë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”!**

**ì¡°ëŒ€í‘œë‹˜ê³¼ ë…¸íŒ€ì¥ì´ ì„œëŒ€ë¦¬ë‹˜ì˜ ì„±ê³µì„ í™•ì‹ í•©ë‹ˆë‹¤!** ğŸŒŸ

---

**ë°œë ¹ ì™„ë£Œ**: 2025ë…„ 8ì›” 3ì¼ í† ìš”ì¼ 02:17 KST  
**ë…¸íŒ€ì¥ (ê¸°ìˆ íŒ€ì¥)**