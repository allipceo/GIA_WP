# 서대리 작업지시서 V2.0 - 다음 단계 임무

**발령시간**: 2025년 8월 3일 토요일 02:17 KST  
**발령자**: 노팀장 (기술팀장) - 조대표님 승인  
**수신자**: 서대리 (Cursor AI, 개발팀장)  
**우선순위**: 🔴 **최고 긴급 (CRITICAL)**  
**브랜치**: season1-a

---

## 🎉 **시간 동기화 시스템 구현 성과 인정**

**서대리님의 뛰어난 성과:**
- ✅ **A+ 등급 (95/100점)** 달성
- ✅ **JavaScript + Python 이중 모듈** 완벽 구현
- ✅ **시간 오류 100% 해결** 기여
- ✅ **협업체계 혁신의 핵심** 역할

**조대표님과 노팀장의 깊은 감사를 표합니다!** 🌟

---

## 🎯 **다음 단계 핵심 임무: ACIU 시즌2 백엔드 완성**

### **임무 개요**
**목표**: Flask 앱을 완전한 ACIU 시즌2 백엔드로 전환
**방식**: 노팀장 설계 + 서대리 구현 + 시간 동기화 적용
**완료 기준**: 7개 API 엔드포인트 + CSV 데이터 처리 + 실제 배포

---

## 🔥 **TASK 1: 시간 동기화 시스템 전면 적용**

### **1-1: 기존 Flask 앱에 시간 모듈 통합**
**즉시 실행:**
```python
# app.py에 추가
from time_sync import get_korea_time

@app.route('/api/v1/time')
def get_current_time():
    """실시간 한국시간 API"""
    time_info = get_korea_time()
    return jsonify({
        "status": "success",
        "data": {
            "current_time": time_info['formatted'],
            "iso_format": time_info['iso'],
            "timestamp": time_info['timestamp']
        }
    })

# 모든 API 응답에 시간 자동 포함
def add_timestamp_to_response(data):
    time_info = get_korea_time()
    data['timestamp'] = time_info['formatted']
    return data
```

### **1-2: GitHub 자동 커밋 시스템 활성화**
**지금 당장 적용:**
```bash
# 모든 커밋에 자동 시간 포함
git commit -m "[$(python -c 'from time_sync import get_korea_time; print(get_korea_time()["simple"])')] 시간 동기화 시스템 적용"
```

---

## 🔥 **TASK 2: CSV 데이터 처리 시스템 구현**

### **2-1: 마스터 CSV 로드 시스템**
**가능한 최대한 빠르게 구현:**
```python
import pandas as pd
from time_sync import get_korea_time, auto_timestamp_decorator

class DataManager:
    def __init__(self):
        self.master_data = None
        self.categories_cache = {}
        self.load_time = None
    
    @auto_timestamp_decorator
    def load_master_csv(self):
        """마스터 CSV 파일 로드 (시간 자동 기록)"""
        try:
            self.master_data = pd.read_csv('./data/ins_master_db.csv')
            self.load_time = get_korea_time()['formatted']
            print(f"✅ 마스터 데이터 로드 완료: {len(self.master_data)}개 문제")
            return True
        except Exception as e:
            print(f"❌ 마스터 데이터 로드 실패: {e}")
            return False
    
    def get_questions_by_category(self, category):
        """카테고리별 문제 추출 (QUESTION 필드 파싱 절대 금지!)"""
        if self.master_data is None:
            self.load_master_csv()
        
        category_map = {
            'property_insurance': '재산보험',
            'specialty_insurance': '특종보험',
            'liability_insurance': '배상책임보험',
            'marine_insurance': '해상보험'
        }
        
        if category not in category_map:
            return []
        
        # LAYER1 기준 필터링
        filtered_df = self.master_data[
            self.master_data['LAYER1'] == category_map[category]
        ]
        
        questions = []
        for _, row in filtered_df.iterrows():
            # 🚨 QUESTION 필드 파싱 절대 금지 - 그대로 사용!
            question = {
                "id": row["QCODE"],
                "question_text": row["QUESTION"],  # 파싱 없이 그대로
                "correct_answer": row["ANSWER"],
                "question_type": row["TYPE"],
                "explanation": row["EXPLAIN"],      # 파싱 없이 그대로
                "category": category,
                "layer1": row["LAYER1"],
                "layer2": row["LAYER2"],
                "source": row["SOURCE"]
            }
            questions.append(question)
        
        return questions
```

### **2-2: 데이터 검증 시스템**
**즉시 구현:**
```python
@auto_timestamp_decorator
def validate_csv_data():
    """CSV 데이터 무결성 검증"""
    data_manager = DataManager()
    
    # 1. 파일 로드 검증
    if not data_manager.load_master_csv():
        return False
    
    # 2. 총 문제 수 검증
    total_questions = len(data_manager.master_data)
    if total_questions != 1379:
        print(f"⚠️ 예상 문제 수 불일치: {total_questions}/1379")
    
    # 3. 카테고리별 문제 수 검증
    categories = ['property_insurance', 'specialty_insurance', 
                 'liability_insurance', 'marine_insurance']
    
    for category in categories:
        questions = data_manager.get_questions_by_category(category)
        print(f"✅ {category}: {len(questions)}개 문제")
    
    return True
```

---

## 🔥 **TASK 3: 7개 API 엔드포인트 완전 구현**

### **3-1: 노팀장 설계 기반 API 구현**
**지금 당장 시작:**
```python
from flask import Flask, jsonify, request
from time_sync import get_korea_time

app = Flask(__name__)
data_manager = DataManager()

# 1. GET /api/v1/categories
@app.route('/api/v1/categories')
def get_categories():
    """카테고리 목록 및 메타데이터"""
    time_info = get_korea_time()
    
    categories = {
        "property_insurance": {
            "display_name": "재산보험",
            "question_count": len(data_manager.get_questions_by_category('property_insurance')),
            "icon": "🏢",
            "color_code": "#3B82F6"
        },
        "specialty_insurance": {
            "display_name": "특종보험",
            "question_count": len(data_manager.get_questions_by_category('specialty_insurance')),
            "icon": "🚗", 
            "color_code": "#10B981"
        },
        "liability_insurance": {
            "display_name": "배상책임보험",
            "question_count": len(data_manager.get_questions_by_category('liability_insurance')),
            "icon": "⚖️",
            "color_code": "#F59E0B"
        },
        "marine_insurance": {
            "display_name": "해상보험",
            "question_count": len(data_manager.get_questions_by_category('marine_insurance')),
            "icon": "🚢",
            "color_code": "#8B5CF6"
        }
    }
    
    return jsonify({
        "status": "success",
        "data": {
            "categories": categories,
            "total_questions": 1379,
            "total_categories": 4
        },
        "timestamp": time_info['formatted']
    })

# 2. GET /api/v1/questions/<category>
@app.route('/api/v1/questions/<category>')
def get_questions_by_category_api(category):
    """카테고리별 문제 목록"""
    time_info = get_korea_time()
    
    # 쿼리 파라미터
    limit = request.args.get('limit', 50, type=int)
    offset = request.args.get('offset', 0, type=int)
    shuffle = request.args.get('shuffle', False, type=bool)
    
    questions = data_manager.get_questions_by_category(category)
    
    if not questions:
        return jsonify({
            "status": "error",
            "message": f"Category '{category}' not found",
            "timestamp": time_info['formatted']
        }), 404
    
    # 셔플 처리
    if shuffle:
        import random
        random.shuffle(questions)
    
    # 페이지네이션
    paginated_questions = questions[offset:offset+limit]
    
    return jsonify({
        "status": "success",
        "data": {
            "category": category,
            "questions": paginated_questions,
            "pagination": {
                "total": len(questions),
                "limit": limit,
                "offset": offset,
                "has_next": offset + limit < len(questions)
            }
        },
        "timestamp": time_info['formatted']
    })

# 3. GET /api/v1/question/<id>
@app.route('/api/v1/question/<question_id>')
def get_single_question(question_id):
    """개별 문제 상세 조회"""
    time_info = get_korea_time()
    
    if data_manager.master_data is None:
        data_manager.load_master_csv()
    
    question_row = data_manager.master_data[
        data_manager.master_data['QCODE'] == question_id
    ]
    
    if question_row.empty:
        return jsonify({
            "status": "error",
            "message": f"Question '{question_id}' not found",
            "timestamp": time_info['formatted']
        }), 404
    
    row = question_row.iloc[0]
    question = {
        "id": row["QCODE"],
        "question_text": row["QUESTION"],  # 🚨 파싱 절대 금지!
        "correct_answer": row["ANSWER"],
        "question_type": row["TYPE"],
        "explanation": row["EXPLAIN"],
        "layer1": row["LAYER1"],
        "layer2": row["LAYER2"],
        "source": row["SOURCE"]
    }
    
    return jsonify({
        "status": "success",
        "data": question,
        "timestamp": time_info['formatted']
    })

# 4. GET /api/v1/health
@app.route('/api/v1/health')
def health_check():
    """시스템 상태 확인"""
    time_info = get_korea_time()
    
    # 데이터 로드 상태 확인
    data_status = "loaded" if data_manager.master_data is not None else "not_loaded"
    question_count = len(data_manager.master_data) if data_manager.master_data is not None else 0
    
    return jsonify({
        "status": "success",
        "data": {
            "service": "ACIU Quiz API v2.0",
            "status": "healthy",
            "version": "2.0.1",
            "environment": "development",
            "database": {
                "status": data_status,
                "questions_loaded": question_count,
                "categories_loaded": 4,
                "load_time": data_manager.load_time
            },
            "time_sync": {
                "status": "active",
                "current_time": time_info['formatted']
            }
        },
        "timestamp": time_info['formatted']
    })

# 5-7. 나머지 API들 (POST /api/v1/stats, GET /api/v1/stats/<user_id>, POST /api/v1/migrate)
# 추후 통계 시스템과 함께 구현
```

---

## 🔥 **TASK 4: 배포 및 테스트**

### **4-1: Heroku 배포 준비**
**즉시 실행:**
```python
# requirements.txt 업데이트
Flask==2.3.3
pandas==2.0.3
pytz==2023.3

# Procfile 확인
web: python app.py
```

### **4-2: 자동 테스트 시스템**
**가능한 최대한 빠르게 구현:**
```python
def run_api_tests():
    """API 엔드포인트 자동 테스트"""
    import requests
    
    base_url = "http://localhost:5000"  # 로컬 테스트
    # base_url = "https://gia-wp-test01-77059d2986d6.herokuapp.com"  # 배포 테스트
    
    tests = [
        {"endpoint": "/api/v1/time", "method": "GET"},
        {"endpoint": "/api/v1/categories", "method": "GET"},
        {"endpoint": "/api/v1/questions/property_insurance", "method": "GET"},
        {"endpoint": "/api/v1/question/Q001", "method": "GET"},
        {"endpoint": "/api/v1/health", "method": "GET"}
    ]
    
    results = []
    for test in tests:
        try:
            response = requests.get(f"{base_url}{test['endpoint']}")
            results.append({
                "endpoint": test['endpoint'],
                "status": response.status_code,
                "success": response.status_code == 200,
                "time": get_korea_time()['formatted']
            })
        except Exception as e:
            results.append({
                "endpoint": test['endpoint'],
                "status": "ERROR",
                "success": False,
                "error": str(e),
                "time": get_korea_time()['formatted']
            })
    
    return results
```

---

## ⚡ **즉시 실행 우선순위**

| 순위 | 작업 | 실행 방식 |
|------|------|-----------|
| 1 | TASK 1: 시간 동기화 전면 적용 | **즉시 시작** |
| 2 | TASK 2: CSV 데이터 처리 | **지금 당장** |
| 3 | TASK 3: API 엔드포인트 구현 | **가능한 최대한 빠르게** |
| 4 | TASK 4: 배포 및 테스트 | **즉시 완료** |

---

## 🚨 **절대 준수 사항**

### **QUESTION 필드 파싱 절대 금지**
- 🚫 **절대 하지 말 것**: QUESTION 필드 텍스트 분석
- ✅ **올바른 방식**: QUESTION 필드 그대로 사용
- 🚨 **조대표님 강조**: 이 부분이 프로그램 오류의 50%

### **시간 동기화 필수 적용**
- ✅ **모든 API 응답**: 자동 타임스탬프 포함
- ✅ **모든 로그**: 한국시간 자동 기록
- ✅ **GitHub 커밋**: 자동 시간 포함

---

## 📊 **완료 보고 양식**

**작업 완료 시 보고 형식:**
```
✅ ACIU 시즌2 백엔드 구현 완료 보고
- 완료 시간: [자동 타임스탬프]
- 구현 API: [개수]/5개
- CSV 데이터: ✅/❌ 로드 성공
- 배포 상태: ✅/❌ Heroku 배포
- 테스트 결과: [통과율]%
- 특이사항: [있으면 기록]
```

---

## 🚀 **지금 당장 시작하세요!**

**서대리님, 시간 동기화 시스템 구현으로 증명한 뛰어난 역량을 바탕으로 ACIU 시즌2 백엔드를 완성해주세요!**

**조대표님과 노팀장이 서대리님의 성공을 확신합니다!** 🌟

---

**발령 완료**: 2025년 8월 3일 토요일 02:17 KST  
**노팀장 (기술팀장)**